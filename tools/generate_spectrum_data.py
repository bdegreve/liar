#! /usr/bin/env python

"""
Generate spectral data for Spectrum class using Smitt's algorithm

Using Brian Smits' algorithm described in "An RGB to Spectrum Conversion for Reflectances"
https://www.cs.utah.edu/~bes/papers/color/
"""

import scipy
import scipy.linalg
import scipy.optimize
from matplotlib import pyplot
import liar
import liar.tools.rgb_spaces
import os
import re

def main(numBins, minWavelength, maxWavelength, rgbSpaceName, niter=10000, fitall=False):
    wavelengthBins = scipy.linspace(minWavelength, maxWavelength, numBins + 1)
    xyzObserver = scipy.transpose(scipy.array(map(liar.standardObserver.tristimulus, zip(wavelengthBins[:-1], wavelengthBins[1:]))))

    rgbSpace = get_rgb_space(rgbSpaceName)
    rgbObserver = xyz_to_rgb(xyzObserver, rgbSpace)

    white, yellow, magenta, cyan, red, green, blue = generate_base_spectra(rgbObserver, niter, fitall)

    write_code_fragments(wavelengthBins, rgbSpace, niter, fitall, xyzObserver, white, yellow, magenta, cyan, red, green, blue)

    if fitall:
        steps(wavelengthBins, white, 'k')
        pyplot.figure()

    steps(wavelengthBins, red, 'r')
    steps(wavelengthBins, green, 'g')
    steps(wavelengthBins, blue, 'b')
    steps(wavelengthBins, (red + green + blue), 'k:')
    pyplot.figure()

    steps(wavelengthBins, yellow, 'y')
    steps(wavelengthBins, magenta, 'm')
    steps(wavelengthBins, cyan, 'c')
    steps(wavelengthBins, (yellow + magenta + cyan) / 2, 'k:')
    pyplot.show()


def get_rgb_space(name):
    rgbSpace = liar.tools.rgb_spaces.__dict__.get(name)
    if not isinstance(rgbSpace, liar.RgbSpace):
        raise KeyError("%s is not an RgbSpace in liar.tools.rgb_spaces" % name)
    return liar.RgbSpace(rgbSpace.red, rgbSpace.green, rgbSpace.blue, (1./3, 1./3), 1.)


def xyz_to_rgb(A, rgbSpace):
    _, n = scipy.shape(A)
    return scipy.transpose([rgbSpace.toRGBAlinear(A[:,k])[:3] for k in range(n)])



def generate_base_spectra(A, niter, fitall=False):
    null_A = null(A)
    pinv_A = scipy.linalg.pinv(A)

    _, n = scipy.shape(A)
    constwhite = scipy.ones(n)
    print constwhite

    white = fit(1, 1, 1, null_A, pinv_A, niter) if fitall else constwhite
    yellow  = fit(1, 1, 0, null_A, pinv_A, niter)
    magenta = fit(1, 0, 1, null_A, pinv_A, niter)
    cyan    = fit(0, 1, 1, null_A, pinv_A, niter)
    red     = fit(1, 0, 0, null_A, pinv_A, niter) if fitall else constwhite - cyan
    green   = fit(0, 1, 0, null_A, pinv_A, niter) if fitall else constwhite - magenta
    blue    = fit(0, 0, 1, null_A, pinv_A, niter) if fitall else constwhite - yellow

    return white, yellow, magenta, cyan, red, green, blue


def null(A, eps=1e-15):
    # http://mail.scipy.org/pipermail/scipy-user/2005-June/004650.html
    # http://mail.scipy.org/pipermail/scipy-user/2008-December/019064.html
    n, m = scipy.shape(A)
    if n > m:
        return scipy.transpose(null(scipy.transpose(A), eps))
    u, s, vh = scipy.linalg.svd(A)
    assert m >= n
    s = scipy.append(s, [0] * (m - n))
    null_mask = (s <= eps)
    null_space = scipy.compress(null_mask, vh, axis=0)
    return scipy.transpose(null_space)


def fit(r, g, b, null_A, pinv_A, niter):
    print "fitting", r, g, b
    rgb = scipy.array([r, g, b])
    x = scipy.dot(pinv_A, rgb)
    _, n = scipy.shape(null_A)
    s0 = [.5] * n

    kwargs = {
        'method': 'COBYLA',
        'args': (x, null_A),
        #'bounds': [(0,1)]*n,
        'constraints': [
                {'type':'ineq', 'fun': lambda s, x, null_A: min(x + scipy.dot(null_A, s)), 'args': (x, null_A)},
                {'type':'ineq', 'fun': lambda s, x, null_A: 1.2 - max(x + scipy.dot(null_A, s)), 'args': (x, null_A)},
            ],
        'options': {
            'disp': False,
            },
        }
    
    optimal = scipy.optimize.basinhopping(error, s0, minimizer_kwargs=kwargs, niter=niter)
    s = x + scipy.dot(null_A, optimal.x)

    #s = [max(0, min(v, 1)) for v in s]   # clamp between 0 and 1

    print s
    return s


def error(s, x, null_A, *args):
    y = x + scipy.dot(null_A, s)
    mx = 100 * (max(y) - 1) if max(y) > 1 else 0 # penalty for values > 1
    mx += (-1000 * min(y)) if min(y) < 0 else 0
    return 10 * scipy.linalg.norm(scipy.diff(y)) + mx


def write_code_fragments(wavelengthBins, rgbSpace, niter, fitall, A, white, yellow, magenta, cyan, red, green, blue):
    self_dir = os.path.dirname(os.path.abspath(__file__))
    kernel_dir = os.path.join(os.path.dirname(self_dir), "src", "kernel")

    _, n = scipy.shape(A)

    meta_info = [
        "// Generated by %s with %d bins from %s to %s, using %s iterations, fitall=%s\n" % (os.path.basename(__file__), n, wavelengthBins[0], wavelengthBins[-1], niter, fitall)
        ]

    # spectrum.h
    block = [
        'enum { numBands = %d };\n' % n
        ]
    replace_block(os.path.join(kernel_dir, "spectrum.h"), block, "numBands", meta_info)

    # spectrum.cpp
    chromaticities = (rgbSpace.red, rgbSpace.green, rgbSpace.blue, rgbSpace.white)

    block = ['TRgbSpacePtr rgbSpace(new RgbSpace(\n']
    block += ['    TPoint2D(%s, %s),\n' % (floatstr(x), floatstr(y)) for (x, y) in chromaticities]
    block += ['    %s));\n' % floatstr(rgbSpace.gamma)]

    block += array_block('const XYZ A', ['XYZ(%s, %s, %s)' % tuple(map(floatstr, A[:,k])) for k in range(n)])
    block += array_block('const TWavelength w', map(floatstr, wavelengthBins))
    block += array_block('const TScalar yellow', map(floatstr, yellow))
    block += array_block('const TScalar magenta', map(floatstr, magenta))
    block += array_block('const TScalar cyan', map(floatstr, cyan))
    block += array_block('const TScalar red', map(floatstr, red))
    block += array_block('const TScalar green', map(floatstr, green))
    block += array_block('const TScalar blue', map(floatstr, blue))
    replace_block(os.path.join(kernel_dir, "spectrum.cpp"), block, "initData", meta_info)


def replace_block(path, new_block_lines, name, meta_info):
    open_tag = "/* start autogen block %s */" % name
    close_tag = "/* end autogen block %s */" % name

    print "updating %s" % path

    out = []
    with open(path, 'r') as f:
        # search start of block
        for line in f:
            out.append(line)
            match = re.match(r"(\s*)%s\s*$" % re.escape(open_tag), line)
            if match:
                indentation = match.group(1)
                break
        else:
            raise RuntimeError("could not find start of autogen block %s" % name)

        # insert new block
        for line in (meta_info + new_block_lines):
            out.append(indentation + line)

        # search end of block
        for line in f:
            match = re.match(r"(\s*)%s\s*$" % re.escape(close_tag), line)
            if match:
                out.append(line)
                break
        else:
            raise RuntimeError("could not find end of autogen block %s" % name)

        # add remainder of lines
        for line in f:
            out.append(line)

    with open(path, 'w') as f:
        f.writelines(out)


def array_block(head, values):
    values = list(values)
    block = [
        '\n',
        head + '[%d] =\n' % len(values),
        '{\n',
        ]
    block += ['    %s,\n' % v for v in values]
    block += [
        '};\n',
        ]
    return block


def floatstr(x):
    return "%#gf" % x


def steps(Xs, Ys, c):
    pyplot.step(Xs, scipy.append(Ys, [0]), c, where='post')


#W_MIN, W_MAX, SIZE = 360e-9, 800e-9, 20
#W_MIN, W_MAX, SIZE = 380e-9, 720e-9, 10

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description='Generate the Spectrum<->XYZ conversion constants.')
    parser.add_argument("-n", "--num-bins", type=int, default=10, metavar='<n>', help="number of bands in spectrum [default=%(default)s]")
    parser.add_argument("-w", "--w-min", type=float, default=360e-9, metavar='<w>', help="lower wavelength bound of spectrum [default=%(default)s]")
    parser.add_argument("-W", "--w-max", type=float, default=800e-9, metavar='<w>', help="upper wavelength bound of spectrum [default=%(default)s]")
    parser.add_argument("--niter", type=int, default=10000, metavar='<n>', help="number of iterations in optimization algorithm, more is better [default=%(default)s]")
    parser.add_argument("--rgb-space", type=str, default="sRGB", metavar='<name>', help="RGB space to be used, name of one of the spaces in liar.rgb_spaces [default=%(default)s]")
    parser.add_argument("--fit-all", default=False, action="store_true", help="Also fit white, red, green and blue instead of just yellow, magenta and cyan.")
    args = parser.parse_args()
    main(args.num_bins, args.w_min, args.w_max, args.rgb_space, args.niter, args.fit_all)


