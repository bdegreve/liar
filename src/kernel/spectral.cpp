/** @file
 *  @author Bram de Greve (bramz@users.sourceforge.net)
 *
 *  LiAR isn't a raytracer
 *  Copyright (C) 2004-2010  Bram de Greve (bramz@users.sourceforge.net)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *  http://liar.bramz.net/
 */

#include "kernel_common.h"
#include "recovery.h"
#include "rgb_space.h"
#include "sample.h"
#include "spectral.h"

namespace liar
{
namespace kernel
{

Spectral::Spectral()
{
}


Spectral::Spectral(TValue f):
	v_(f)
{
}


Spectral::Spectral(TValue f, SpectralType type) :
	v_(type == Reflectant ? std::min(f, TNumTraits::one) : f)
{
}


Spectral::Spectral(const TBands& v, SpectralType type):
	v_(v)
{
	if (type == Reflectant)
	{
		const TScalar max = v_.maximum();
		if (max > 1)
		{
			v_ /= max;
		}
	}
}

#if LIAR_SPECTRAL_MODE_SMITS

Spectral Spectral::fromXYZ(const XYZ& xyz, const Sample&, SpectralType type)
{
	const prim::ColorRGBA rgb = pimpl_->rgbSpace->linearConvert(xyz);
	
	if (rgb.r <= rgb.g)
	{
		if (rgb.r <= rgb.b) 
		{
			if (rgb.g <= rgb.b)
			{
				LASS_ASSERT(rgb.r <= rgb.g && rgb.r <= rgb.b && rgb.g <= rgb.b);
				TBands v(rgb.r);
				v.fma(rgb.g - rgb.r, pimpl_->cyan);
				v.fma(rgb.b - rgb.g, pimpl_->blue);
				return Spectral(v, type);
			}
			else
			{
				LASS_ASSERT(rgb.r <= rgb.b && rgb.r <= rgb.g && rgb.b <= rgb.g);
				TBands v(rgb.r);
				v.fma(rgb.b - rgb.r, pimpl_->cyan);
				v.fma(rgb.g - rgb.b, pimpl_->green);
				return Spectral(v, type);
			}
		}
		else
		{
			LASS_ASSERT(rgb.b <= rgb.r && rgb.b <= rgb.g && rgb.r <= rgb.g);
			TBands v(rgb.b);
			v.fma(rgb.r - rgb.b, pimpl_->yellow);
			v.fma(rgb.g - rgb.r, pimpl_->green);
			return Spectral(v, type);
		}
	}
	else if (rgb.g <= rgb.b)
	{
		if (rgb.r <= rgb.b)
		{
			LASS_ASSERT(rgb.g <= rgb.r && rgb.g <= rgb.b && rgb.r <= rgb.b);
			TBands v(rgb.g);
			v.fma(rgb.r - rgb.g, pimpl_->magenta);
			v.fma(rgb.b - rgb.r, pimpl_->blue);
			return Spectral(v, type);
		}
		else
		{
			LASS_ASSERT(rgb.g <= rgb.b && rgb.g <= rgb.r && rgb.b <= rgb.r);
			TBands v(rgb.g);
			v.fma(rgb.b - rgb.g, pimpl_->magenta);
			v.fma(rgb.r - rgb.b, pimpl_->red);
			return Spectral(v, type);
		}
	}
	else
	{
		LASS_ASSERT(rgb.b <= rgb.g && rgb.b <= rgb.r && rgb.g <= rgb.r);
		TBands v(rgb.b);
		v.fma(rgb.g - rgb.b, pimpl_->yellow);
		v.fma(rgb.r - rgb.g, pimpl_->red);
		return Spectral(v, type);
	}
}

Spectral Spectral::fromSampled(const std::vector<TWavelength>& wavelengths, const std::vector<TScalar>& values, const Sample&, SpectralType type)
{
	return fromSampled(wavelengths, values, type);
}

Spectral Spectral::fromSampled(const std::vector<TWavelength>& wavelengths, const std::vector<TScalar>& values, SpectralType type)
{
	// can be done better!
	LASS_ASSERT(wavelengths.size() == values.size());
	const size_t n = wavelengths.size();
	const auto &bands = pimpl_->bands;

	Spectral result;
	size_t i = 0;
	size_t k1 = 0, k2 = 1;
	while (k2 < n && i < numBands)
	{
		TWavelength w1 = wavelengths[k1];
		if (w1 >= bands[i + 1])
		{
			++i;
			continue;
		}

		TWavelength w2 = wavelengths[k2];
		TWavelength dw = w2 - w1;
		if (dw <= 0)
		{
			continue;
		}

		TScalar v1 = values[k1];
		TScalar v2 = values[k2];
		TScalar dv = v2 - v1;

		if (w1 < bands[i])
		{
			v1 = v1 + dv * (bands[i] - w1) / dw;
			w1 = bands[i];
		}
		if (w2 > bands[i + 1])
		{
			v2 = v1 + dv * (bands[i + 1] - w1) / dw;
			w2 = bands[i + 1];
		}

		result.v_[i] += (v1 + v2) * (w2 - w1) / 2; // can't reuse dw

		k1 = k2++;
	}

	if (type == Reflectant)
	{
		const TScalar max = result.v_.maximum();
		if (max > 1)
		{
			result /= max;
		}
	}

	return result;
}

const XYZ Spectral::xyz(const Sample&) const
{
	XYZ sum = 0;
	for (size_t k = 0; k < numBands; ++k)
	{
		sum += pimpl_->observer[k] * v_[k];
	}
	return sum;
}



Spectral::Impl::Impl()
{
	/* start autogen block initData */
	// Generated by generate_spectrum_data.py with 10 bins from 3.6e-07 to 8e-07, using 100000 iterations, fitall=False
	rgbSpace.reset(new RgbSpace(
		TPoint2D(0.640000f, 0.330000f),
		TPoint2D(0.300000f, 0.600000f),
		TPoint2D(0.150000f, 0.0600000f),
		TPoint2D(0.333333f, 0.333333f),
		1.00000f));

	const XYZ A[numBands] =
	{
		XYZ(0.00179643f, 5.03579e-05f, 0.00850556f),
		XYZ(0.0855167f, 0.00471796f, 0.423513f),
		XYZ(0.0787251f, 0.0429831f, 0.500759f),
		XYZ(0.0263265f, 0.239723f, 0.0636773f),
		XYZ(0.233830f, 0.396741f, 0.00321433f),
		XYZ(0.404543f, 0.248992f, 0.000305128f),
		XYZ(0.155119f, 0.0616462f, 8.50378e-06f),
		XYZ(0.0134617f, 0.00490018f, 0.00000f),
		XYZ(0.000648948f, 0.000234413f, 0.00000f),
		XYZ(2.84654e-05f, 1.02801e-05f, 0.00000f),
	};

	const TWavelength w[numBands + 1] =
	{
		3.60000e-07f,
		4.04000e-07f,
		4.48000e-07f,
		4.92000e-07f,
		5.36000e-07f,
		5.80000e-07f,
		6.24000e-07f,
		6.68000e-07f,
		7.12000e-07f,
		7.56000e-07f,
		8.00000e-07f,
	};

	const TScalar y[numBands] =
	{
		0.00787763f,
		-5.55112e-17f,
		0.149163f,
		0.911415f,
		0.999910f,
		0.999438f,
		0.957385f,
		0.962723f,
		0.957981f,
		0.969991f,
	};

	const TScalar m[numBands] =
	{
		0.991654f,
		0.999989f,
		0.906348f,
		0.0136420f,
		0.0131883f,
		0.814659f,
		0.999976f,
		0.998238f,
		0.999411f,
		0.997143f,
	};

	const TScalar c[numBands] =
	{
		0.949163f,
		0.922302f,
		1.01817f,
		1.01819f,
		1.01810f,
		0.190733f,
		-4.85723e-17f,
		0.0224848f,
		0.0225910f,
		0.0394559f,
	};

	const TScalar r[numBands] =
	{
		0.0508371f,
		0.0776981f,
		-0.0181744f,
		-0.0181913f,
		-0.0180974f,
		0.809267f,
		1.00000f,
		0.977515f,
		0.977409f,
		0.960544f,
	};

	const TScalar g[numBands] =
	{
		0.00834648f,
		1.11093e-05f,
		0.0936516f,
		0.986358f,
		0.986812f,
		0.185341f,
		2.42438e-05f,
		0.00176182f,
		0.000589059f,
		0.00285692f,
	};

	const TScalar b[numBands] =
	{
		0.992122f,
		1.00000f,
		0.850837f,
		0.0885851f,
		8.97977e-05f,
		0.000561824f,
		0.0426151f,
		0.0372773f,
		0.0420186f,
		0.0300094f,
	};
	/* end autogen block initData */

	for (size_t k = 0; k < numBands; ++k)
	{
		observer[k] = A[k];
		bands[k] = w[k];
		yellow[k] = y[k];
		magenta[k] = m[k];
		cyan[k] = c[k];
		red[k] = r[k];
		green[k] = g[k];
		blue[k] = b[k];
	}
	bands[numBands] = w[numBands];
}


Spectral::Impl* Spectral::pimpl_ = new Spectral::Impl();


#elif LIAR_SPECTRAL_MODE_RGB

Spectral Spectral::fromXYZ(const XYZ& xyz, const Sample&, SpectralType type)
{
	const RgbSpace::RGBA rgb = RgbSpace::defaultSpace()->linearConvert(xyz);
	return Spectral(TBands(rgb.r, rgb.g, rgb.b), type);
}

Spectral Spectral::fromSampled(const std::vector<TWavelength>& wavelengths, const std::vector<TScalar>& values, const Sample&, SpectralType type)
{
	return fromSampled(wavelengths, values, type);
}

Spectral Spectral::fromSampled(const std::vector<TWavelength>& wavelengths, const std::vector<TScalar>& values, SpectralType type)
{
	const XYZ xyz = standardObserver().tristimulus(wavelengths, values);
	const RgbSpace::RGBA rgb = RgbSpace::defaultSpace()->linearConvert(xyz);
	return Spectral(TBands(rgb.r, rgb.g, rgb.b), type);
}

const XYZ Spectral::xyz(const Sample&) const
{
	return RgbSpace::defaultSpace()->linearConvert(RgbSpace::RGBA(v_[0], v_[1], v_[2]));
}

#elif LIAR_SPECTRAL_MODE_SINGLE

Spectral Spectral::fromXYZ(const XYZ& xyz, const Sample& sample, SpectralType type)
{
	return standardRecovery().recover(xyz, sample, type);
}

Spectral Spectral::fromSampled(const std::vector<TWavelength>& wavelengths, const std::vector<TScalar>& values, const Sample& sample, SpectralType type)
{
	LASS_ASSERT(wavelengths.size() > 1 && wavelengths.size() == values.size());
	const size_t k = std::upper_bound(wavelengths.begin(), wavelengths.end(), sample.wavelength()) - wavelengths.begin();
	if (k == 0 || k == wavelengths.size())
	{
		return Spectral(0);
	}

	LASS_ASSERT(wavelengths[k] > wavelengths[k - 1]);
	const TScalar t = (sample.wavelength() - wavelengths[k - 1]) / (wavelengths[k] - wavelengths[k - 1]);
	const TScalar v = num::lerp(values[k - 1], values[k], t);

	if (type == Reflectant)
	{
		const TScalar max = *std::max_element(values.begin(), values.end());
		if (max > 1)
		{
			return Spectral(v / max);
		}
	}
	return Spectral(v);
}

const XYZ Spectral::xyz(const Sample& sample) const
{
	TScalar pdf = 0;
	const TWavelength w = sample.wavelength(pdf);
	if (pdf <= 0)
	{
		return XYZ(0);
	}
	return (v_[0] / pdf) * standardObserver().sensitivity(w);
}

#endif

}
}

// EOF
