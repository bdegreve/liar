/** @file
 *  @author Bram de Greve (bramz@users.sourceforge.net)
 *
 *  LiAR isn't a raytracer
 *  Copyright (C) 2004-2010  Bram de Greve (bramz@users.sourceforge.net)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *  http://liar.bramz.net/
 */

#include "kernel_common.h"
#include "spectral.h"
#include "rgb_space.h"
#include "sample.h"

namespace liar
{
namespace kernel
{

Spectral::Spectral()
{
}


Spectral::Spectral(TValue f):
	v_(f)
{
}


#if LIAR_SPECTRAL_BANDS

Spectral Spectral::fromXYZ(const XYZ& xyz, const Sample&)
{
	const prim::ColorRGBA rgb = pimpl_->rgbSpace->linearConvert(xyz);
	
	if (rgb.r <= rgb.g)
	{
		if (rgb.r <= rgb.b) 
		{
			if (rgb.g <= rgb.b)
			{
				LASS_ASSERT(rgb.r <= rgb.g && rgb.r <= rgb.b && rgb.g <= rgb.b);
				TBands v(rgb.r);
				v.fma(rgb.g - rgb.r, pimpl_->cyan);
				v.fma(rgb.b - rgb.g, pimpl_->blue);
				return Spectral(v);
			}
			else
			{
				LASS_ASSERT(rgb.r <= rgb.b && rgb.r <= rgb.g && rgb.b <= rgb.g);
				TBands v(rgb.r);
				v.fma(rgb.b - rgb.r, pimpl_->cyan);
				v.fma(rgb.g - rgb.b, pimpl_->green);
				return Spectral(v);
			}
		}
		else
		{
			LASS_ASSERT(rgb.b <= rgb.r && rgb.b <= rgb.g && rgb.r <= rgb.g);
			TBands v(rgb.b);
			v.fma(rgb.r - rgb.b, pimpl_->yellow);
			v.fma(rgb.g - rgb.r, pimpl_->green);
			return Spectral(v);
		}
	}
	else if (rgb.g <= rgb.b)
	{
		if (rgb.r <= rgb.b)
		{
			LASS_ASSERT(rgb.g <= rgb.r && rgb.g <= rgb.b && rgb.r <= rgb.b);
			TBands v(rgb.g);
			v.fma(rgb.r - rgb.g, pimpl_->magenta);
			v.fma(rgb.b - rgb.r, pimpl_->blue);
			return Spectral(v);
		}
		else
		{
			LASS_ASSERT(rgb.g <= rgb.b && rgb.g <= rgb.r && rgb.b <= rgb.r);
			TBands v(rgb.g);
			v.fma(rgb.b - rgb.g, pimpl_->magenta);
			v.fma(rgb.r - rgb.b, pimpl_->red);
			return Spectral(v);
		}
	}
	else
	{
		LASS_ASSERT(rgb.b <= rgb.g && rgb.b <= rgb.r && rgb.g <= rgb.r);
		TBands v(rgb.b);
		v.fma(rgb.g - rgb.b, pimpl_->yellow);
		v.fma(rgb.r - rgb.g, pimpl_->red);
		return Spectral(v);
	}
}

TScalar Spectral::absAverageFromXYZ(const XYZ& xyz)
{
	return abs(xyz).average(); // not really, but maybe close enough.
}

const XYZ Spectral::xyz() const
{
	XYZ sum = 0;
	for (size_t k = 0; k < numBands; ++k)
	{
		sum += pimpl_->observer[k] * v_[k];
	}
	return sum;
}



Spectral::Impl::Impl()
{
	/* start autogen block initData */
	// Generated by generate_spectrum_data.py with 10 bins from 3.6e-07 to 8e-07, using 100000 iterations, fitall=False
	rgbSpace.reset(new RgbSpace(
		TPoint2D(0.640000f, 0.330000f),
		TPoint2D(0.300000f, 0.600000f),
		TPoint2D(0.150000f, 0.0600000f),
		TPoint2D(0.333333f, 0.333333f),
		1.00000f));

	const XYZ A[numBands] =
	{
		XYZ(0.00179643f, 5.03579e-05f, 0.00850556f),
		XYZ(0.0855167f, 0.00471796f, 0.423513f),
		XYZ(0.0787251f, 0.0429831f, 0.500759f),
		XYZ(0.0263265f, 0.239723f, 0.0636773f),
		XYZ(0.233830f, 0.396741f, 0.00321433f),
		XYZ(0.404543f, 0.248992f, 0.000305128f),
		XYZ(0.155119f, 0.0616462f, 8.50378e-06f),
		XYZ(0.0134617f, 0.00490018f, 0.00000f),
		XYZ(0.000648948f, 0.000234413f, 0.00000f),
		XYZ(2.84654e-05f, 1.02801e-05f, 0.00000f),
	};

	const TWavelength w[numBands + 1] =
	{
		3.60000e-07f,
		4.04000e-07f,
		4.48000e-07f,
		4.92000e-07f,
		5.36000e-07f,
		5.80000e-07f,
		6.24000e-07f,
		6.68000e-07f,
		7.12000e-07f,
		7.56000e-07f,
		8.00000e-07f,
	};

	const TScalar y[numBands] =
	{
		0.00787763f,
		-5.55112e-17f,
		0.149163f,
		0.911415f,
		0.999910f,
		0.999438f,
		0.957385f,
		0.962723f,
		0.957981f,
		0.969991f,
	};

	const TScalar m[numBands] =
	{
		0.991654f,
		0.999989f,
		0.906348f,
		0.0136420f,
		0.0131883f,
		0.814659f,
		0.999976f,
		0.998238f,
		0.999411f,
		0.997143f,
	};

	const TScalar c[numBands] =
	{
		0.949163f,
		0.922302f,
		1.01817f,
		1.01819f,
		1.01810f,
		0.190733f,
		-4.85723e-17f,
		0.0224848f,
		0.0225910f,
		0.0394559f,
	};

	const TScalar r[numBands] =
	{
		0.0508371f,
		0.0776981f,
		-0.0181744f,
		-0.0181913f,
		-0.0180974f,
		0.809267f,
		1.00000f,
		0.977515f,
		0.977409f,
		0.960544f,
	};

	const TScalar g[numBands] =
	{
		0.00834648f,
		1.11093e-05f,
		0.0936516f,
		0.986358f,
		0.986812f,
		0.185341f,
		2.42438e-05f,
		0.00176182f,
		0.000589059f,
		0.00285692f,
	};

	const TScalar b[numBands] =
	{
		0.992122f,
		1.00000f,
		0.850837f,
		0.0885851f,
		8.97977e-05f,
		0.000561824f,
		0.0426151f,
		0.0372773f,
		0.0420186f,
		0.0300094f,
	};
	/* end autogen block initData */

	for (size_t k = 0; k < numBands; ++k)
	{
		observer[k] = A[k];
		bands[k] = w[k];
		yellow[k] = y[k];
		magenta[k] = m[k];
		cyan[k] = c[k];
		red[k] = r[k];
		green[k] = g[k];
		blue[k] = b[k];
	}
	bands[numBands] = w[numBands];
}


Spectral::Impl* Spectral::pimpl_ = new Spectral::Impl();


#else

Spectral Spectral::fromXYZ(const XYZ& xyz, const Sample&)
{
	return Spectral(TBands(xyz.x, xyz.y, xyz.z));
}

TScalar Spectral::absAverageFromXYZ(const XYZ& xyz)
{
	return abs(xyz).average();
}

const XYZ Spectral::xyz() const
{
	return XYZ(v_[0], v_[1], v_[2]);
}

#endif

}
}

// EOF
