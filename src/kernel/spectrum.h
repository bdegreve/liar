/** @file
 *  @author Bram de Greve (bramz@users.sourceforge.net)
 *
 *  LiAR isn't a raytracer
 *  Copyright (C) 2004-2010  Bram de Greve (bramz@users.sourceforge.net)
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *  http://liar.bramz.net/
 */

#ifndef LIAR_GUARDIAN_OF_INCLUSION_KERNEL_KERNEL_SPECTRUM_H
#define LIAR_GUARDIAN_OF_INCLUSION_KERNEL_KERNEL_SPECTRUM_H

#include "kernel_common.h"
#include "rgb_space.h"

namespace liar
{
namespace kernel
{

#if LIAR_FULL_SPECTRAL

class LIAR_KERNEL_DLL Spectrum
{
public:
	typedef TScalar TValue;

	/* start autogen block numBands */
	// Generated by generate_spectrum_data.py with 10 bins from 3.6e-07 to 8e-07, using 100000 iterations
	enum { numBands = 10 };
	/* end autogen block numBands */

	Spectrum();
	Spectrum(TScalar f);
	explicit Spectrum(const XYZ& xyz);

	const XYZ xyz() const;
	operator XYZ() const { return xyz(); }

	TScalar operator[](size_t index) const { return v_[index]; }
	TScalar& operator[](size_t index) { return v_[index]; }

	Spectrum& operator+=(const Spectrum& other);
	Spectrum& operator-=(const Spectrum& other);
	Spectrum& operator*=(const Spectrum& other);
	Spectrum& operator/=(const Spectrum& other);
	TScalar total() const;
	TScalar absTotal() const;
	TScalar average() const { return total() / numBands; }
	bool isZero() const;
	bool operator!() const { return isZero(); }
	operator num::SafeBool() const { return isZero() ? num::safeFalse : num::safeTrue; }

	Spectrum& inplaceAbs();
	Spectrum& inplaceMax(const Spectrum& other);
	Spectrum& inplaceDot(const Spectrum& other);
	Spectrum& inplacePow(TScalar f);
	Spectrum& inplaceExp();
	Spectrum& inplaceClamp(TScalar min, TScalar max);
	Spectrum& inplaceLerp(const Spectrum& other, TScalar f);

	bool operator==(const Spectrum& other) const;

private:
	TValue v_[numBands];

	static XYZ observer_[numBands];
	static TWavelength bands_[numBands + 1];
	static Spectrum yellow_;
	static Spectrum magenta_;
	static Spectrum cyan_;
	static Spectrum red_;
	static Spectrum green_;
	static Spectrum blue_;
	static TRgbSpacePtr rgbSpace_;

	static TRgbSpacePtr initData();
};

inline Spectrum abs(const Spectrum& a) 
{
	Spectrum r(a);
	r.inplaceAbs();
	return r;
}

inline Spectrum max(const Spectrum& a, const Spectrum& b) 
{
	Spectrum r(a);
	r.inplaceMax(b);
	return r;
}

TScalar LASS_DLL dot(const Spectrum& a, const Spectrum& b);

inline Spectrum sqr(const Spectrum& a)
{
	Spectrum r(a);
	r *= a;
	return r;
}

inline Spectrum pow(const Spectrum& a, TScalar b)
{
	Spectrum r(a);
	r.inplacePow(b);
	return r;
}

inline Spectrum exp(const Spectrum& a)
{
	Spectrum r(a);
	r.inplaceExp();
	return r;
}

inline Spectrum clamp(const Spectrum& a, TScalar min, TScalar max)
{
	Spectrum r(a);
	r.inplaceClamp(min, max);
	return r;
}

inline Spectrum lerp(const Spectrum& a, const Spectrum& b, TScalar f)
{
	Spectrum r(a);
	r.inplaceLerp(b, f);
	return r;
}

#else

class Spectrum
{
public:
	typedef TScalar TValue;

	enum { numBands = 3 };

	Spectrum(): xyz_(0) {}
	Spectrum(TScalar f): xyz_(f) {}
	explicit Spectrum(XYZ xyz): xyz_(xyz) {}

	const XYZ xyz() const { return xyz_; }

	TValue operator[](size_t index) const { return (&xyz_.x)[index]; }
	TValue& operator[](size_t index) { return (&xyz_.x)[index]; }

	Spectrum& operator+=(const Spectrum& other) { xyz_ += other.xyz_; return *this; }
	Spectrum& operator-=(const Spectrum& other) { xyz_ -= other.xyz_; return *this; }
	Spectrum& operator*=(const Spectrum& other) { xyz_ *= other.xyz_; return *this; }
	Spectrum& operator/=(const Spectrum& other) { xyz_ /= other.xyz_; return *this; }
	TScalar total() const { return xyz_.total(); }
	TScalar absTotal() const { return xyz_.absTotal(); }
	TScalar average() const { return total() / numBands; }
	bool isZero() const { return xyz_.isZero(); }
	bool operator!() const { return isZero(); }
	operator num::SafeBool() const { return isZero() ? num::safeFalse : num::safeTrue; }

	Spectrum& inplaceAbs() { xyz_ = abs(xyz_); return *this; }
	Spectrum& inplaceMax(const Spectrum& other) { xyz_ = max(xyz_, other.xyz_); return *this; }
	Spectrum& inplacePow(TScalar f) { xyz_ = pow(xyz_, f); return *this; }
	Spectrum& inplaceExp() { xyz_ = exp(xyz); return *this; }
	Spectrum& inplaceClamp(TScalar min, TScalar max) { xyz_ = clamp(xyz_, min, max); return *this; }
	Spectrum& inplaceLerp(const Spectrum& other, TScalar f) { xyz_ = lerp(xyz_, other.xyz_, f); return *this; }

	bool operator==(const Spectrum& other) const { return xyz_ == other.xyz_; }

private:
	XYZ xyz_;
};

inline Spectrum abs(const Spectrum& a) 
{
	return Spectrum(abs(a.xyz());
}

inline Spectrum max(const Spectrum& a, const Spectrum& b) 
{
	return Spectrum(max(a.xyz(), b.xyz());
}

inline TScalar dot(const Spectrum& a, const Spectrum& b)
{
	return dot(a.xyz(), b.xyz());
}

inline Spectrum sqr(const Spectrum& a)
{
	return Spectrum(sqr(a.xyz());
}

inline Spectrum pow(const Spectrum& a, TScalar b)
{
	return Spectrum(pow(a.xyz(), b);
}

inline Spectrum exp(const Spectrum& a)
{
	return Spectrum(exp(a.xyz());
}

inline Spectrum clamp(const Spectrum& a, TScalar min, TScalar max)
{
	return Spectrum(clamp(a.xyz(), min, max));
}

inline Spectrum lerp(const Spectrum& a, const Spectrum& b, TScalar f)
{
	return Spectrum(lerp(a.xyz(), b.xyz(), f));
}

#endif

inline TScalar average(const Spectrum& a)
{
	return a.average();
}

inline Spectrum operator+(const Spectrum& a, const Spectrum& b) 
{
	Spectrum r(a);
	r += b;
	return r;
}

inline Spectrum operator-(const Spectrum& a, const Spectrum& b) 
{
	Spectrum r(a);
	r -= b;
	return r;
}

inline Spectrum operator*(const Spectrum& a, const Spectrum& b) 
{
	Spectrum r(a);
	r *= b;
	return r;
}

inline Spectrum operator/(const Spectrum& a, const Spectrum& b) 
{
	Spectrum r(a);
	r /= b;
	return r;
}


}
}


#endif

// EOF
